#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (c) 2008, 2009, 2010 Janne Blomqvist

#  This file is part of Vasputil.

#  Vasputil is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.

#  Vasputil is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License
#  along with vasputil.  If not, see <http://www.gnu.org/licenses/>.

"""Plot charge density in a plane as created by lev00"""

from optparse import OptionParser

import matplotlib.pyplot as plt
import numpy as np

usage = """%prog [options] datfile

datfile is the charge density in a plane, as created by lev00."""

parser = OptionParser(usage)
parser.add_option('-o', '--output', dest='output', help='Output to file \
instead of displaying the image. The format is deduced from the extension \
of the filename; supported are eps, jpeg, pdf, png, ps, svg')
parser.add_option('-m', '--color-map', dest='cm', help='Colormap, see the \
list at http://www.scipy.org/Cookbook/Matplotlib/Show_colormaps')
parser.add_option('-n', '--normalize', dest='norm', help='Normalize color map. \
If the argument length is 2, use the values for the upper and lower maximum \
values. If length != 0, normalize such that 0 is in the middle; if the argument is a number, that will be the maximum and minimum values, if not, the maximum values in the file will be used.')
parser.add_option('-i', '--inverse', dest='inverse', action='store_true',
                  help='Inverse the colormap')
parser.add_option('-c', '--contour', dest='contour', action='store_true',
                  help='Make a contour plot rather than the default \
                  pseudocolor plot')
parser.add_option('-f', '--filled-contour', dest='fc', action='store_true',
                  help='Make a filled contour plot rather than the default \
                  pseudocolor plot')
parser.add_option('-b', '--bw-contour', dest='bw', action='store_true',
                  help='Make a black-and-white contour plot')
parser.add_option('-l', '--levels', dest='levels', help='Number of levels for contour plots. Alternatively, if the argument is a decimal number, the inter-level difference')
(options, args) = parser.parse_args()

dat = np.loadtxt(args[0])

# Data is stored in text form, with each line containing
# X Y Z
# where Z is the charge density
# However, if the width along the axises are different, the grid points in
# each direction stay constant, but the grid spacing changes.
# So we might need to reinterpolate on a regular grid

n = np.sqrt(dat.shape[0]) # Original num of points in both X and Y directions.
#x, y = meshgrid(dat[0:n, 0], dat[0:n, 1])
x = dat[:,0]
y = dat[:,1]
xmax = x.max()
xmin = x.min()
ymax = y.max()
ymin = y.min()
xr = xmax - xmin
yr = ymax - ymin

xl = np.linspace(xmin, xmax, n)
yl = np.linspace(ymin, ymax, n)
z = np.reshape(dat[:, 2], (n, n))

if xr == yr:
    # No interpolation needed
    pass
else:
    import scipy.interpolate as spi
    # Create 2D interpolator object with original data
    # interp2d goes into an infinite loop?
    #inter2 = spi.interp2d(xl, yl, z)
    inter2 = spi.RectBivariateSpline(xl, yl, z)
    # Reinterpolate only along the bigger dimension
    idim = xr < yr
    if idim: # Y range is bigger
        fac = int(round(n * yr / xr))
        yl = np.linspace(ymin, ymax, fac)
    else:
        fac = int(round(n * xr / yr))
        xl = np.linspace(xmin, xmax, fac)
    z = inter2(xl, yl)
    #ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
    #fig = figure(1)
    #fig.set_figheight(yr)
    #fig.set_figwidth(xr)
    #    pcolor(xl, yl, z.T)
    #fig.set_size_inches(xr, yr)

# This ensures that the aspect ratio of the plot is equivalent to the array.
w, h = plt.figaspect(z.T)
fig = plt.figure(1, figsize=(w+4, h))
a = fig.add_subplot(111)
a.set_aspect(1)

# No idea how to actually inverse the colormap, so inverse the array
# of values instead
if options.inverse:
    z = z * -1

if options.cm:
    cmap = plt.get_cmap(options.cm)
else:
    cmap = plt.cm.hot # hot colormap is good for both color and BW

if options.norm:
    n = options.norm.split()
    if len(n) == 2:
        low = float(n[0])
        high = float(n[1])
    else:
        try:
            high = abs(float(n[0]))
        except ValueError:
            high = max(abs(z.max()), abs(z.min()))
        low = -high
    norm = plt.normalize(low, high)
else:
    norm = None

if options.contour or options.fc or options.bw:
    xm, ym = np.meshgrid(xl, yl)
    if options.levels:
        try:
            lev = int(options.levels)
        except ValueError:
            ld = float(options.levels)
            if not options.norm:
                low = z.min()
                high = z.max()
            lev = np.arange(low, high, ld)
    else:
        lev = 10
    if options.contour:
        plt.contour(xm, ym, z.T, lev, cmap=cmap, norm=norm)
    elif options.fc:
        plt.contourf(xm, ym, z.T, lev, cmap=cmap, norm=norm)
    else:
        plt.contour(xm, ym, z.T, lev, colors='k')
else:
    plt.pcolor(xl, yl, z.T, cmap=cmap, norm=norm)
a.set_xlim(xmin, xmax)
a.set_ylim(ymin, ymax)
if not options.bw:
    plt.colorbar()
# \u00c5 is the unicode literal for 'Ã…'
a.set_xlabel(u'Distance from center (\u00c5)')
a.set_ylabel(u'Distance from center (\u00c5)')
if options.output:
    plt.savefig(options.output)
else:
    plt.show()
